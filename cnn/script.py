'''
Given an input image, this program will generate feature maps at each 
of the five layers of the the VGG-16 CNN model and use agglomerative clustering
to group feature maps by visual similarity, then output to file.

Written by Carl Bettosi

14/08/2021
'''

print('Loading libraries...')

# For everything else
import os

from numpy.core.numeric import full
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
import numpy as np
from numpy import expand_dims
import glob

# Image processing
from keras.applications.vgg16 import preprocess_input
from keras.preprocessing.image import load_img
from keras.preprocessing.image import img_to_array
from keras.applications.vgg16 import decode_predictions
from numpy.core.fromnumeric import shape
from skimage.io import imsave

# Visualisation
import matplotlib.pyplot as plt
from scipy.cluster.hierarchy import dendrogram
from scipy.cluster.hierarchy import _plot_dendrogram

# CNN model
from keras.applications.vgg16 import VGG16
from keras.models import Model

# Clustering
from sklearn.cluster import AgglomerativeClustering

'''
A InputPass object will hold all data relating to one pass of an image through the VGG-16 model.
It contains functions to cluster similar images and save feature map data to local directories.
'''
class InputPass:

    def __init__(self):
        self.all_fmaps = [] # Generated by model output
        self.cluster_models = [] # Each layers clustering data
        self.fmapflat = {1:{}, 2:{}, 3:{}, 4:{}, 5:{}} # {layer : {filename : img_data_flattened}}
        self.fmaps_original = {1:{}, 2:{}, 3:{}, 4:{}, 5:{}} # {layer : {filename : img_data}}
        self.cluster_groups = {1:{}, 2:{}, 3:{}, 4:{}, 5:{}} # {layer: {cluster : filename}}

    '''
    Prepare the input image to be passed into VGG-16 model

    Return: the processed image (ndarray)
    '''
    def process_input_img(self):
        print('Preparing image...')

        img = load_img('mountain_lion.jpg', target_size=(224, 224))
        img = img_to_array(img)

        # Expand dimensions so to represent one sample (1,224,224,3)
        img = expand_dims(img, axis=0)

        # Normalise for VGG-16
        img = preprocess_input(img)
        return img

    '''
    Print the classification result of the image
    '''
    def classify_img(self, img):
        full_model = VGG16()
        prediction = full_model.predict(img)
        label = decode_predictions(prediction)
        # retrieve the most likely result, e.g. highest probability
        label = label[0][0]
        # print the classification
        print('%s (%.2f%%)' % (label[1], label[2]*100))

    '''
    Print all classes
    '''
    def all_classes(self):
        all = decode_predictions(np.expand_dims(np.arange(1000), 0), top=1000)
        print(all)

    '''
    Redefine the model to output after each convolutional block

    Return: a subset of the VGG-16 model with newly defined outputs (tensorflow object)
    '''
    def redefine_VGG16_conv_blocks(self):
        model = VGG16()
        model.summary()

        output_layers = [2, 5, 9, 13, 17]

        # Create new model with indexes of conv layer blocks
        outputs = [model.layers[i].output for i in output_layers]
        sub_model = Model(inputs=model.inputs, outputs=outputs)
        return sub_model

    '''
    Use the passed in image on the newly defined model to generate feature maps at each layer
    Generate feature map names
    Generate flattened list of each layer's maps for cluster preperation
    '''
    def generate_feature_maps(self, model, img):
        print('Generating feature maps...')
        # Define how many feature maps are generated at each layer
        intervals = [64, 128, 256, 512, 512]

        # Generate all feature maps by calling predict on the model
        self.all_fmaps = model.predict(img)

        # Define the naming convention
        current_layer = 0
        for layer in self.all_fmaps:
            for fmap in range(intervals[current_layer]):
                lname = 'layer'+ str(current_layer+1)
                fname = 'map' + str(fmap+1) + '.png'

                # Append filename and corresponding flattened data to dict inside relevant layer dict
                self.fmapflat[current_layer+1][lname+'_'+fname] = layer[0, :, :, fmap].flatten()
                # Same but unflattened (for saving later)
                self.fmaps_original[current_layer+1][lname+'_'+fname] = layer[0, :, :, fmap]
        
            current_layer+=1

    '''
    Perform clustering on each layer and generate a new dictionary of clustered feature maps
    '''
    def agglomerative_clustering(self):
        print('Clustering...')

        # For each layer, cluster on the flattened image data
        for layer in range(1,6):
            # Clustering
            agg = AgglomerativeClustering(distance_threshold=None, n_clusters=24).fit(list(self.fmapflat[layer].values()))
            # Generate dendrogram
            agg_dendrogram = AgglomerativeClustering(distance_threshold=0, n_clusters=None).fit(list(self.fmapflat[layer].values()))
            self.cluster_models.append(agg_dendrogram)

            # Store newly clustered data in new dict with {layer: {cluster : filename}}
            for fname, cluster in zip(self.fmapflat[layer].keys(), agg.labels_):
                if cluster not in self.cluster_groups[layer].keys():
                    self.cluster_groups[layer][cluster] = []
                    self.cluster_groups[layer][cluster].append(fname)
                else:
                    self.cluster_groups[layer][cluster].append(fname)

    '''
    Save the clustered images to file
    '''
    def save_images(self):
        print('Saving images to local file...')
        for layer in self.cluster_groups:
            # Navigate to corresponding layer directory
            os.chdir('layer' + str(layer))
            for cluster in self.cluster_groups[layer]:
                # Navigate to corresponding cluster directory
                os.chdir('cluster' + str(cluster+1))
                # Delelte all old files in current directory
                for f in glob.glob('*'):
                    os.remove(f)
                # For each feature map filename in the clustered dictionary
                for filename in self.cluster_groups[layer][cluster]:
                    # Locate the corresponding filename in the data dictionary and save as .png to current directory
                    imsave(filename, self.fmaps_original[layer][filename])
                os.chdir('..')
            os.chdir('..')

    def save_non_clustered_images(self):
        os.chdir('user_study_maps')
        for fmap in self.fmaps_original[5]:
            imsave(fmap, self.fmaps_original[5][fmap])

    '''
    Plot a dendrogram of heirarchical similarities between each image in a layer
    Adapted from Sci-kit learn docs https://scikit-learn.org/stable/auto_examples/cluster/plot_agglomerative_dendrogram.html
    '''
    def plot_dendrogram(self, model, **kwargs):
        # create the counts of samples under each node
        counts = np.zeros(model.children_.shape[0])
        n_samples = len(model.labels_)
        for i, merge in enumerate(model.children_):
            current_count = 0
            for child_idx in merge:
                if child_idx < n_samples:
                    current_count += 1  # leaf node
                else:
                    current_count += counts[child_idx - n_samples]
            counts[i] = current_count

        linkage_matrix = np.column_stack([model.children_, model.distances_, 
                                        counts]).astype(float)

        # Plot the corresponding dendrogram
        dendrogram(linkage_matrix, **kwargs, truncate_mode='lastp', p=24)

    '''
    The main control flow of the program
    '''
    def main(self):
        input_img = self.process_input_img()
        model = self.redefine_VGG16_conv_blocks()
        self.generate_feature_maps(model, input_img)
        self.agglomerative_clustering()
        self.save_images()
        self.save_non_clustered_images()
        self.classify_img(input_img)

        # Uncomment to view dendrogram outputs for each layer
        '''for plot in range (0,5):
            temp = []
            for fname in self.fmapflat[plot+1].keys():
                temp.append(fname)
            plt.title('Hierarchical Clustering Dendrogram (Layer ' + str(plot+1) + ')')
            self.plot_dendrogram(self.cluster_models[plot], labels = temp)
            plt.show()'''


# Run program
program = InputPass()
program.main()

